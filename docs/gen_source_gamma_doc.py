#! /usr/bin/env python

#This script is passed a path for a source.F90 file (e.g. from the parent
#  directory).  It searches the file for all subroutines, and copies the 
#  comments in the lines that immediately follow. A 'fake' python script is then generated
# 
# Expected comment format: either a # or ! symbol, followed by one space, and then the contents of the comment. #This is bad; # This is ok. 
# '#This' becomes 'his'; '#  and this' becomes ' and this'.

import sys
import os

comchar = '!#' #valid comment characters


def main():
    if not os.path.isfile(sys.argv[1]):
        print "File", sys.argv[1], "not found."
        sys.exit(1)
    if sys.argv[1] == "source.F90":
        print "File", sys.argv[1], "has same name as script output; " \
                "script will not overwrite the original."

    if len(sys.argv) >= 3:
        outfile = sys.argv[2]
    else:
        outfile = "source_gamma_doc.py"

    print "Generating documentation for Fortran code in {0}...".format( \
            sys.argv[1])

    fr = open(sys.argv[1], 'r')
    fw = open(outfile, 'w')

    # Note origin of file, and open leading docstring
    fw.write("# File auto-generated by gen_source_gamma_doc.py for parsing " \
            "by sphinx-apidoc. Not an actual script.\n\n")
    fw.write('"""{0}\n'.format(sys.argv[1]))
    fw.write(len(sys.argv[1]) * '=' + '\n')

    line = fr.readline()
    # look for header comment
    if len(line) > 2 and line[:2] == "!+":
        print "  Header found and being skipped."
        # skip over header comment
        while line.split():
            line = fr.readline()
        # skip over following empty lines
        while not line.split():
            line = fr.readline()

    #####################
    # Handle text for leading docstring
    while line.split() and line.split()[0] in comchar:
        fw.write(line.lstrip(comchar)[1:])
        line = fr.readline()

    fw.write('\n"""\n\n\n')

    #################
    # Find and handle all subroutines
    while line:
        if line.split() and line.split()[0].lower() == 'subroutine':
            line = gen_method(line, fr, fw)

        line = fr.readline()

    fr.close()
    fw.close()

       
def gen_method(line, fr, fw):
    """Parse a subroutine and create python method
    """
    name = line.split()[1]
    print '  generated definition for method...', name

    while line.strip()[-1] == '&':
        if line[0] in comchar:
            print >>sys.stderr, "ERROR: comment line follows an '&' character."
            fr.close()
            fw.close()
            sys.exit(1)
        line = fr.readline()

    comments = list()

    line = fr.readline()
    while line.strip() and line.strip()[0] in comchar:
        comments.append(line)
        line = fr.readline()

    fw.write('def {0}():\n    """'.format(name))
    for line in comments:
        fw.write(line.lstrip(comchar)[1:] + '    ' )

    fw.write('"""\n' \
            '    pass\n\n')

    return line


if __name__ == '__main__':
    if len(sys.argv) > 1:
        main()
    else:
        print "ERROR: Need to pass the path to a .F90 file."
        sys.exit(1)
